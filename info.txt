¿Qué es una PWA?
No hay una definición concreta sobre que es una PWA. Lo mejor es entender como es el panorama actual.
Pero podemos definirlo como un estandar de calidad, de como deberia ser la web pensada primera para mobile y mejorar su performance

¿Cómo es la web hoy?

Spoiler Alert: No funciona muy bien en mobile.
Más del 50% de nuestros usuarios está en mobile.
Tenemos malas conexiones en los dispositivos móviles, conexiones tipo 3G y LTE no son particularmente confiables. Esto genera que un sitio promedio tarda 14 segundos en cargar en mobile.
La UX no es solamente el diseño de nuestra app, tiene que ver con que tan rápido funciona nuestra aplicación en el mundo real, con un teléfono que tiene una conexión mala.
Hay estudios que demuestran la importancia de lograr que tu sitio funcione rápidamente en dispositivos móviles:
• 50% de los usuarios se van de un sitio que tarda más de 3 segundos en cargar.
• Cada segundo de demora nos cuesta un 5-10% de nuestras ventas.

Vamos a centrarnos en tres cosas a lo largo de este curso:
   Performance.
   Instalable en Homescreen.
   Dar soporte Offline.


---- El proyecto ----
Nuestro proyecto será Platzi Recetas: una PWA para ver recetas que utiliza la API de TheMealDB.
Solamente usaremos React, generado por Create React App, junto con React Router.


---- Google Lighthouse ----
Es una herramienta oficial de Google que viene con Chrome, con la cual podemos hacer un diagnóstico a una Web App. Estos diagnósticos se centran en Performance y Accesibilidad, pero también tiene una herramienta para diagnosticar si nuestra Web App se considera una PWA o no y que pasos debemos de tomar para que lo sea.
Lighthouse no sustituye hacer pruebas con un dispositivo móvil real, siempre realiza pruebas en un dispositivo móvil.

El diagnostico de Performance nos muestra dos de los conceptos más importantes en performance: First meaningful Paint y First interactive.
    -First meaningful Paint o primer pintado significativo, esto señala cuanto tiempo tardo el navegador en renderizar la aplicación de una forma que tenga sentido. Generalmente queremos que este situado entre 1 y 2 segundos.
    -First interactive o primera interacción, señala el tiempo cuando ya se cargó React y esta disponible nuestra app, inicializo la aplicación y que podamos correr comandos dentro de la aplicación.

¿Cómo bajamos estos tiempos?
Para bajar el Time To First Meaningful Paint (TTFMP - momento donde nuestra app se puede ver) podemos hacer Server Side Rendering, reducir el tamaño de nuestro HTML y CSS o simplemente teniendo servidores más rápidos O usar CDNS.
El Time To Interactive tiene mucho que ver con el framework que estemos utilizando,   queremos que tarde menos de 5 segundos.


---- Creando un Web Manifest ----
En esta clase vamos a ver cómo implementar la funcionalidad de Add to Homescreen.

Nota IMPORTANTE:

Al momento de crear este curso esta saliendo Chrome 68, dicha versión va a cambiar el comportamiento del Add to Homescreen sutilmente.
create-react-app nos da un Web Manifest pre armado el cual debemos configurar. Todo lo que tiene que ver con nuestro Web Manifest está dentro de los archivos index.html y manifest.json de la carpeta public de nuestro proyecto.

Por el momento vamos a trabajar dentro del archivo manifest.json, en el podemos ver varios atributos, los cuales son:
• short_name: Es el nombre que se utiliza en la Homescreen.
• name: Es el nombre de nuestra aplicación.
• icons: Especifica un array de imágenes que servirán como iconos de la aplicación. Cambiaremos el “favicon.ico” por “icon.png”, especificamos el tamaño a 512x512 y el tipo a “image/png”.
• start_url: Nos indica en que página comienza nuestra aplicación, por compatibilidad siempre conviene que sea “/” en lugar de “./index.html”.
• display: Define el modo de visualización para la aplicación. Standalone significa que la aplicación puede correr por su misma.
• theme_color: Define qué color vamos a usar en la barra de tareas de Android para que combine con nuestra aplicación.
• related_applications: Sirve si queremos que Chrome en el Add to Homescreen recomiende una aplicación del Store.

Para probar nuestro Add to Homescreen debemos tener en cuenta que un requisito fundamental de las PWA es que todo funcione con HTTPS.
Nuestra aplicación por defecto es fullscreen, así que NO OLVIDES de brindar un camino al home.
En iOS necesitamos añadir alguna metadata al index.html de nuestro proyecto. Al momento de probar nuestra aplicación en iOS nos daremos cuenta de que el Add to Homescreen en este caso debe ser añadido manualmente por el usuario.

-NGROK: es un tunel con un servidor HTTPS y que dirije directamente a nuestra PC
tenemos que instalar NGROK y pasamos el archivo ngrok a una ruta cualquiera puede ser la raiz, y logearnos https://dashboard.ngrok.com/get-started/setup ya luego tenemos que iniciar el build en local (ejemplo puerto 4000 esta corriendo en local) y pasar el puerto a NGROK asi ./ngrok http 4000 con eso ya tenemos nuestra URL con HTTPS

Para iphone agregar estos metadata para IOS en el index.html
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <meta name="apple-mobile-web-app-title" content="Recetas" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-status-bar-style" content="black-translucent" />



---- ¿Qué es un Service Worker? ----
Son la característica más importante de una PWA.
Es lo que hace posible que las PWA funcionen, es un script que nuestro navegador corre detrás de escena y este no puede tocar el DOM.
Podemos tener control absoluto a nivel red de nuestra aplicación gracias a los service workers. Por lo que podemos dar soporte Offline o tambien podemos usar push notifications


---- Introducción a Workbox ----
En esta clase vamos a ver como implementar service workers en nuestra aplicación.
Los service workers solo funcionan en producción.
Una recomendación siempre que trabajemos con service workers es ir a Clear Storage en la tab de Application de las DevTools, y limpiar la información del sitio. Esto desinstalara todo lo que es cache y limpiara los service workers.

Quienes habrán prestado atención a la documentación de create-react-app habrán leído que este incluye un service worker.
El service worker de Create React App hace algo llamado “SW Precache“, lo que hace es precargar y dejar disponibles offline todos los archivos necesarios para correr la aplicación. Una recomendación a la hora de hacer debugging es refrescar el sitio pues un service worker por lo general se inicializa después de la primera carga.

NUNCA conviene escribir nuestro propio service worker especialmente con herramientas de bajo nivel.
Para implementar nuestro propio service worker usaremos Workbox, una librería creada por Google para crear Service Workers.
Hay un pequeño detalle al momento de implementar Workbox en nuestro proyecto y es que estamos yendo en contra de los principios de Create React App y esto solo significa una cosa “eject”, esto nos llenaría de archivos que no nos sirven. Para evitar hacer eject vamos a instalar react-app-rewired y el plugin para webpack de workbox.

npm add workbox-webpack-plugin react-app-rewire-workbox react-app-rewired | adicional en la raiz del proyecto creamos un config-overrides.js y dentro del src el service-worker.js y los script del package cambiarlos por react-app-rewired ejemplo => "dev": "react-app-rewired start",


---- Implementando Workbox ----
En esta clase vamos a ver como implementar estrategias de carga con Workbox.

El funcionamiento de un service worker por defecto toma una lista de assets para precargarlos y si la ruta coincide exactamente con un asset entonces lo tomara de cache.

Workbox tiene una característica llamada registerNavigationRoute la cual se encarga de hacer el funcionamiento por defecto de un service worker más aparte si encuentra una url que no conoce va a buscar una url, en este caso index.html y que el se encargue de lo que va a mostrar.
workbox.routing.registerNavigationRoute('/index.html') | nueva linea en el config-overrides.js

Existen diferentes estrategias de carga.
La primera y fundamental se llama Network Only. Esta se encarga checar si hay conexión a internet, si existe una conexión realiza la petición de información, en caso de no haber conexión se rompe la página.

¿Cuándo usar Network Only?
Por defecto si no queremos cache o manejamos información en tiempo real.

Network First es otra estrategia de carga, se encarga mandar la petición a internet, si la conexión a internet esta caída entonces tomara la información que tenga almacenada en cache.
¿Cuándo usar Network First?
Cuando queremos la última versión de un asset y tener soporte offline.